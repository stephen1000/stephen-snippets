""" Emits records into a system until a desired threshold is reached """
import threading
import time
from concurrent.futures import ThreadPoolExecutor
from csv import DictWriter
from pathlib import Path
from sys import getsizeof
from textwrap import dedent
from typing import Callable, Optional


class Populator:
    """
    Tool for emitting data into a system

    :param writer: A function that can receive the current record number and
        return a writer class to write that record to
    :param constructor: A function that returns a model that implements
        ``ippon.data..util.fakable.FakableModel``
    :param file_size_limit_bytes: Max number of bytes per file
    :param file_size_limit_records: Max number of records per file
    :param total_size_limit_bytes: Max number of total bytes
    :param total_size_limit_records: Max number of total records
    """

    def __init__(
        self,
        writer: Callable,
        constructor: Callable,
        file_size_limit_bytes: Optional[int] = None,
        file_size_limit_records: Optional[int] = None,
        total_size_limit_bytes: Optional[int] = None,
        total_size_limit_records: Optional[int] = None,
    ):
        self.writer = writer
        self.constructor = constructor
        self.file_size_limit_bytes = file_size_limit_bytes or float("inf")
        self.file_size_limit_records = file_size_limit_records or float("inf")
        self.total_size_limit_bytes = total_size_limit_bytes or float("inf")
        self.total_size_limit_records = total_size_limit_records or float("inf")
        self.total_size_bytes = 0
        self.total_size_records = 0
        if not (self.file_size_limit_bytes or self.file_size_limit_records):
            raise TypeError(
                dedent(
                    """
                One of ``file_size_limit_bytes`` or ``file_size_limit_records``
                must be specified
                !"""
                )
            )
        if not (self.total_size_limit_bytes or self.total_size_limit_records):
            raise TypeError(
                dedent(
                    """
                One of ``total_size_limit_bytes`` or ``total_size_limit_records`` must
                be specified!"
                """
                )
            )

    def populate_all(self):
        """Populates ``self.writer`` with records generated by ``constructor``"""
        with ThreadPoolExecutor() as executor:
            future_count = 0
            while (self.total_size_bytes < self.total_size_limit_bytes) and (
                self.total_size_records < self.total_size_limit_records
            ):
                while threading.active_count() > executor._max_workers:
                    time.sleep(0.1)
                path = Path(f"./tmp/spoof_test/outfile_{future_count}.csv")
                executor.submit(
                    self.populate,
                    DictWriter(
                        path.open("w", encoding="utf-8", newline=""),
                        fieldnames=list(self.constructor().keys()),
                    ),
                )
                future_count += 1
                print(
                    f"{future_count=}, {self.total_size_bytes=}, {self.total_size_records=}"
                )

    def populate(self, csv_writer: DictWriter) -> None:
        """Populates an individual file"""
        size_in_bytes = 0
        size_in_records = 0
        while (
            (size_in_bytes < self.file_size_limit_bytes)
            and (size_in_records < self.file_size_limit_records)
            and (self.total_size_bytes < self.total_size_limit_bytes)
            and (self.total_size_records < self.total_size_limit_records)
        ):
            record = self.constructor()
            csv_writer.writerow(record)
            size_in_records += 1
            self.total_size_records += 1
            size_in_bytes += getsizeof(record)
            self.total_size_bytes += getsizeof(record)


if __name__ == "__main__":
    from ippon.data.fake.models.call_center.call_detail import CallDetail

    populator = Populator(
        writer=lambda i: i,
        constructor=lambda: CallDetail.spoof().as_dict(),
        total_size_limit_bytes=1024 * 1000 * 1000 * 5,
        file_size_limit_bytes=1024 * 1000 * 100,
    )
    populator.populate_all()
